<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql分页]]></title>
    <url>%2F2019%2F09%2F17%2Fmysql%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[1、Mysql的limit用法在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，mysql已经为我们提供了这样一个功能。 Sql代码 1234567SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #。~~~ Sql代码 mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目：mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15 //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last. //如果只给定一个参数，它表示返回最大的记录行数目：mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行 //换句话说，LIMIT n 等价于 LIMIT 0,n。 【引用，路人乙:Mysql中limit的用法详解】 12345678### 2、Mysql的分页查询语句的性能分析 MySql分页sql语句，如果和MSSQL的TOP语法相比，那么MySQL的LIMIT语法要显得优雅了许多。使用它来分页是再自然不过的事情了。 #### 2.1最基本的分页方式： Sql代码 SELECT … FROM … WHERE … ORDER BY … LIMIT … SELECT … FROM … WHERE … ORDER BY … LIMIT … 在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好： 1Sql代码 SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10 12345 #### 2.2子查询的分页方式： 随着数据量的增加，页数会越来越多，查看后几页的SQL就可能类似：Sql代码 SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 10 123一言以蔽之，就是越往后分页，LIMIT语句的偏移量就会越大，速度也会明显变慢。此时，我们可以通过子查询的方式来提高分页效率，大致如下：Sql代码 SELECT * FROM articles WHERE id &gt;= (SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) LIMIT 10SELECT * FROM articles WHERE id &gt;= (SELECT id FROM articles WHERE category_id = 123 ORDER BY id LIMIT 10000, 1) LIMIT 10 123#### 2.3JOIN分页方式 Sql代码 SELECT * FROM content AS t1JOIN (SELECT id FROM content ORDER BY id desc LIMIT “.(page−1)∗pagesize.”, 1) AS t2WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize;SELECT * FROM content AS t1JOIN (SELECT id FROM content ORDER BY id desc LIMIT “.($page-1)*$pagesize.”, 1) AS t2WHERE t1.id &lt;= t2.id ORDER BY t1.id desc LIMIT $pagesize; 经过我的测试，join分页和子查询分页的效率基本在一个等级上，消耗的时间也基本一致。explain SQL语句：id select_type table type possible_keys key key_len ref rows Extra1 PRIMARY system NULL NULL NULL NULL 11 PRIMARY t1 range PRIMARY PRIMARY 4 NULL 6264 Using where2 DERIVED content index NULL PRIMARY 4 NULL 27085 Using index 123456789101112---------------------------------------- 为什么会这样呢？因为子查询是在索引上完成的，而普通的查询时在数据文件上完成的，通常来说，索引文件要比数据文件小得多，所以操作起来也会更有效率。 实际可以利用类似策略模式的方式去处理分页，比如判断如果是一百页以内，就使用最基本的分页方式，大于一百页，则使用子查询的分页方式。【引用原文，energy1010的空间：MySql分页sql语句】 ### 3、Oracle分页查询语句Oralce数据库 从数据库表中第M条记录开始检索N条记录 Sql代码 SELECT * FROM (SELECT ROWNUM r,t1.* From 表名称 t1 where rownum &lt; M + N) t2 where t2.r &gt;= MSELECT * FROM (SELECT ROWNUM r,t1.* From 表名称 t1 where rownum &lt; M + N) t2 where t2.r &gt;= M 12 例如从表Sys_option（主键为sys_id)中从第10条记录开始检索20条记录，语句如下： Sql代码 SELECT * FROM (SELECT ROWNUM R,t1.* From Sys_option where rownum &lt; 30 ) t2Where t2.R &gt;= 10SELECT * FROM (SELECT ROWNUM R,t1.* From Sys_option where rownum &lt; 30 ) t2Where t2.R &gt;= 10 12345678910### 3、MSSQLSERVER分页查询语句 SQL Server主要利用 SELECT TOP语句分页，具体方案，请参考 ------------------------------------- 分页方案一：(利用Not In和SELECT TOP分页) 语句形式： Sql代码 SELECT TOP 10 *FROM TestTableWHERE (ID NOT IN(SELECT TOP 20 idFROM TestTableORDER BY id))ORDER BY IDSELECT TOP 10 *FROM TestTableWHERE (ID NOT IN(SELECT TOP 20 idFROM TestTableORDER BY id))ORDER BY ID 1Sql代码 SELECT TOP 页大小 *FROM TestTableWHERE (ID NOT IN(SELECT TOP 页大小页数 idFROM 表ORDER BY id))ORDER BY IDSELECT TOP 页大小 *SELECT TOP 页大小 *FROM TestTableWHERE (ID NOT IN(SELECT TOP 页大小页数 idFROM 表ORDER BY id))ORDER BY IDSELECT TOP 页大小 * 1Sql代码 FROM TestTableWHERE (ID &gt;(SELECT MAX(id)FROM (SELECT TOP 页大小页数 idFROM 表ORDER BY id) AS T))ORDER BY IDFROM TestTableWHERE (ID &gt;(SELECT MAX(id)FROM (SELECT TOP 页大小页数 idFROM 表ORDER BY id) AS T))ORDER BY ID 12345------------------------------------- 分页方案二：(利用ID大于多少和SELECT TOP分页） 语句形式： Sql代码 SELECT TOP 10 *FROM TestTableWHERE (ID &gt;(SELECT MAX(id)FROM (SELECT TOP 20 idFROM TestTableORDER BY id) AS T))ORDER BY IDSELECT TOP 10 *FROM TestTableWHERE (ID &gt;(SELECT MAX(id)FROM (SELECT TOP 20 idFROM TestTableORDER BY id) AS T))ORDER BY ID 1234------------------------------------- 分页方案三：(利用SQL的游标存储过程分页) Sql代码 create procedure XiaoZhengGe@sqlstr nvarchar(4000), –查询字符串@currentpage int, –第N页@pagesize int –每页行数asset nocount ondeclare @P1 int, –P1是游标的id@rowcount intexec sp_cursoropen @P1 output,@sqlstr,@scrollopt=1,@ccopt=1,@rowcount=@rowcount outputselect ceiling(1.0@rowcount/@pagesize) as 总页数–,@rowcount as 总行数,@currentpage as 当前页set @currentpage=(@currentpage-1)@pagesize+1exec sp_cursorfetch @P1,16,@currentpage,@pagesizeexec sp_cursorclose @P1set nocount offcreate procedure XiaoZhengGe@sqlstr nvarchar(4000), –查询字符串@currentpage int, –第N页@pagesize int –每页行数asset nocount ondeclare @P1 int, –P1是游标的id@rowcount intexec sp_cursoropen @P1 output,@sqlstr,@scrollopt=1,@ccopt=1,@rowcount=@rowcount outputselect ceiling(1.0@rowcount/@pagesize) as 总页数–,@rowcount as 总行数,@currentpage as 当前页set @currentpage=(@currentpage-1)@pagesize+1exec sp_cursorfetch @P1,16,@currentpage,@pagesizeexec sp_cursorclose @P1set nocount off ~其它的方案：如果没有主键，可以用临时表，也可以用方案三做，但是效率会低。建议优化的时候，加上主键和索引，查询效率会提高。 通过SQL 查询分析器，显示比较：我的结论是:分页方案二：(利用ID大于多少和SELECT TOP分页）效率最高，需要拼接SQL语句分页方案一：(利用Not In和SELECT TOP分页) 效率次之，需要拼接SQL语句分页方案三：(利用SQL的游标存储过程分页) 效率最差，但是最为通用]]></content>
  </entry>
  <entry>
    <title><![CDATA[新科宅]]></title>
    <url>%2F2019%2F09%2F16%2F%E6%96%B0%E7%A7%91%E5%AE%85%2F</url>
    <content type="text"><![CDATA[第三方阿萨德 列表1 列表2 a 子列表1 b 子列表2 列表3 百度 字体是斜线的字体是不是加粗了是撒打算 12weqeqeqwqeewqe 我的内容是引用的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F15%2Fhexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[title: hexo个人博客创建步骤date: 2019-09-15 18:50:15tags: 第一步 安装node.js 查看安装的版本 安装cnpm工具npm install -g cnpm –registry=https://registry.npm.taobao.org 第二步 利用cnpm安装hexo框架 第三步 新建blog文件夹（日后博客相关的目录放在这里边） 第四步 然后进入到新建的blog文件中 第五步 使用hexo init命令初始化一个博客 第六步 启动博客 新建一篇文章 然后编辑文章的内容，然后重新clean一下和重新生成一下，然后重新启动博客，可在浏览器查看效果 第七步__在github上创建一个仓库，命名规范github用户名.github.io 第八步 下载一个git插件 第九步 修改_config.yml文件 第十步 部署到远端hexo d输入github用户名和密码部署成功通过==chendalei123de56.github.io==路径访问 第十一步 修改主题 安装主题到指定目录 修改配置文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
